Разница между REST и gRPC. Это два фундаментально разных подхода к построению API.

### Краткая суть (TL;DR)

*   **REST** — это архитектурный стиль, использующий **HTTP-запросы (GET, POST, PUT, DELETE)** к ресурсам (URL) для обмена данными, обычно в формате **JSON**. Он человекочитаемый и универсальный.
*   **gRPC** — это современный фреймворк для удалённого вызова процедур (RPC), который использует **HTTP/2** и бинарный формат **Protocol Buffers (Protobuf)**. Он создан для высокой производительности и связи между сервисами внутри распределённых систем.

---

### Детальное сравнение

Давайте разберём отличия по ключевым параметрам.

#### 1. Архитектурная модель

*   **REST**: Следует принципам REST (Representational State Transfer). Вся система строится вокруг понятия **"ресурсы"** (например, `/users`, `/products`). Вы взаимодействуете с ресурсами, используя стандартные HTTP-методы (CRUD-операции).
    *   `GET /users/123` — получить пользователя с id=123
    *   `POST /users` — создать нового пользователя
    *   `PUT /users/123` — обновить пользователя с id=123

*   **gRPC**: Следует модели **RPC (Remote Procedure Call)**. Клиент вызывает методы на сервере так, будто это локальные функции/методы в его коде. Система строится вокруг **сервисов и методов**.
    *   `client.getUser(UserRequest{id: 123})` — вызывается метод `getUser` на сервере.
    *   `client.createUser(User{name: "Ivan"})` — вызывается метод `createUser`.

#### 2. Контракт и сериализация

Это одно из самых важных отличий.

*   **REST**: Контракт (формат запроса и ответа) обычно описывается в документации (например, OpenAPI/Swagger). Для сериализации данных используется текстовый формат **JSON** (реже XML).
    *   **Плюсы:** Человекочитаемый, легко дебажить (можно смотреть в DevTools браузера или логить).
    *   **Минусы:** Относительно большой размер payload, парсинг JSON затратен по CPU.

*   **gRPC**: Контракт **строго определяется** в `.proto`-файлах с помощью языка **Protocol Buffers**. Затем из этого файла кодогенератор создаёт классы на Java, Kotlin, Go, Python и др.
    *   **Пример `.proto`-файла:**
        ```protobuf
        syntax = "proto3";

        message UserRequest {
          int32 id = 1;
        }

        message UserResponse {
          int32 id = 1;
          string name = 2;
          string email = 3;
        }

        service UserService {
          rpc GetUser (UserRequest) returns (UserResponse);
        }
        ```
    *   **Плюсы:** Строгая типизация, автоматическая генерация кода клиента и сервера, исключаются ошибки из-за несоответствия типов. Данные сериализуются в **бинарный формат**, который очень компактен и быстро парсится.
    *   **Минусы:** Нечитаем для человека, нужны специальные инструменты для дебага (например, `grpcurl`).

#### 3. Протокол и производительность

*   **REST**: Работает поверх **HTTP/1.1**. Один TCP-connection на запрос (хотя есть keep-alive). Текстовые заголовки повторяются в каждом запросе. Нет встроенной поддержки потоковой передачи.
*   **gRPC**: Работает поверх **HTTP/2**. Это даёт огромные преимущества:
    *   **Мультиплексирование:** Многие запросы могут выполняться параллельно в рамках одного TCP-соединения, устраняя проблема head-of-line blocking.
    *   **Бинарные заголовки HPACK:** Они сжимаются, что уменьшает накладные расходы.
    *   **Встроенные потоки:** Поддерживает 4 типа вызовов:
        1.  **Унарный** (как обычный REST-запрос): Запрос - Ответ.
        2.  **Серверный поток:** Клиент делает один запрос, а сервер присылает поток ответов (например, лента новостей).
        3.  **Клиентский поток:** Клиент отправляет поток запросов, а сервер возвращает один ответ (например, загрузка батча данных).
        4.  **Двунаправленный поток:** Обе стороны обмениваются потоками сообщений асинхронно (например, чат).

В результате **gRPC значительно быстрее и эффективнее** REST по производительности и использованию сети.

#### 4. Браузерная поддержка и экосистема

*   **REST**: Полностью поддерживается браузерами. Это *де-факто* стандарт для публичных API, которые должны быть доступны из JavaScript.
*   **gRPC**: Прямая поддержка в браузерах ограничена. Для веба используется **gRPC-Web**, который требует специальный прокси для преобразования трафика. Идеально подходит для бэкенд-сервисов, микросервисов и мобильных приложений.

---

### Сводная таблица

| Параметр | REST (JSON/HTTP) | gRPC |
| :--- | :--- | :--- |
| **Контракт** | Слабая типизация, опционально OpenAPI | Строгая типизация, обязательный `.proto`-файл |
| **Формат данных** | Текстовый (JSON/XML) | Бинарный (Protocol Buffers) |
| **Протокол** | HTTP/1.1 | HTTP/2 |
| **Производительность** | Ниже (большие заголовки, текстовый парсинг) | **Выше** (компактный бинарный формат, мультиплексирование) |
| **Потоковая передача** | Ограничена (WebSockets, SSE) | **Встроенная поддержка** 4-х типов |
| **Браузерная поддержка** | **Отличная** | Требует gRPC-Web |
| **Безопасность** | HTTPS (TLS) | Встроенная поддержка аутентификации через creds |

---

### Что и когда выбирать? Практические рекомендации для Java/Kotlin разработчика

*   **Выбирайте REST, если:**
    *   Вы создаёте **публичное API**, которое должно быть легко потребляемо из браузеров, мобильных приложений или любым клиентом, который не поддерживает gRPC.
    *   Вам важна **простота отладки** и человекочитаемость трафика.
    *   Ваша команда больше знакома с веб-технологиями, и вам не критична максимальная производительность.

*   **Выбирайте gRPC, если:**
    *   Вы строите **микросервисную архитектуру** (особенно на Kotlin/Java/Go), где сервисы интенсивно общаются друг с другом. Его производительность и эффективность бьют REST по всем параметрам.
    *   Вам нужна **строгая типизация** и гарантия того, что клиент и сервер соблюдают контракт. Кодогенерация — это огромный плюс.
    *   Вам нужны **потоковые возможности** (чаты, real-time уведомления, передача больших наборов данных).
    *   Вы работаете в контролируемой среде (бэкенд для бэкенда, мобильные приложения).

В современных системах часто используется гибридный подход: **REST для внешнего API** и **gRPC для внутренней коммуникации между микросервисами**.

---
