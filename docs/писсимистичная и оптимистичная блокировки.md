# Что такое пессимистичная и оптимистичная блокировки? Как они работают и зависят ли от Spring Boot 3.4.5 и Kotlin?

- Пессимистичная (`pessimistic`) блокировка — запись блокируется на время транзакции, другие операции ждут до ее окончания. 
  Полезна при высоком конфликте доступа.
- Оптимистичная (`optimistic`) блокировка — блокировка происходит только при подтверждении изменений. 
  Конфликты проверяются `по версии` или `контрольному полю`. Если другой пользователь изменил данные, транзакция откатывается.
- В Spring Boot с JPA и Kotlin можно использовать аннотации `@Lock(LockModeType.PESSIMISTIC_WRITE)` для писсимистичной 
  и версионное поле с `@Version` для оптимистичной.
- Выбор зависит от частоты конфликтов и требований к производительности. Оптимистичная блокировка экономит ресурсы при редких конфликтах.
- Эти механизмы реализуются на уровне базы и ORM, поэтому зависят от используемых библиотек (`Spring Data`, `Hibernate`), 
  а не от языка Kotlin напрямую.[12][13][14][15][16]

---

Приведу примеры кода в Spring Boot с Kotlin для каждого из перечисленных пунктов, включая работу с блокировками.

### 1. Создание индекса в PostgreSQL (через JDBC или миграции)
Сам индекс создается на уровне БД, обычно через миграции (например, с Flyway или Liquibase):

Пример миграции SQL:
```sql
CREATE INDEX idx_person_lastname ON person(lastname);
```

В Kotlin (JPA) для ускорения поиска по lastname используйте аннотацию индекса на сущности:
```kotlin
import jakarta.persistence.*

@Entity
@Table(name = "person", indexes = [Index(name = "idx_person_lastname", columnList = "lastname")])
data class Person (
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long = 0,
    val firstname: String,
    val lastname: String
)
```

### 2. Партиционирование таблиц в PostgreSQL — делается на уровне SQL, в Kotlin просто работаете с основной таблицей.

Пример SQL для создания партиционированной таблицы:
```sql
CREATE TABLE measurement (
    id SERIAL PRIMARY KEY,
    city_id int NOT NULL,
    logdate date NOT NULL,
    temp int
) PARTITION BY RANGE (logdate);

CREATE TABLE measurement_2025_01 PARTITION OF measurement
FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

CREATE TABLE measurement_2025_02 PARTITION OF measurement
FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');
```

Kotlin/Spring Boot код остается стандартным репозиторием для `measurement`:
```kotlin
@Entity
@Table(name = "measurement")
data class Measurement(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long = 0,
    val cityId: Int,
    val logdate: LocalDate,
    val temp: Int
)

interface MeasurementRepository : JpaRepository<Measurement, Long>
```

### 3. Шардирование — это архитектурное решение, на уровне приложения и инфраструктуры, пример кода зависит от реализации, но здесь простой пример использования нескольких репозиториев:

```kotlin
interface UserRepositoryShard1 : JpaRepository<User, Long> { /* подключение к shard1 */ }
interface UserRepositoryShard2 : JpaRepository<User, Long> { /* подключение к shard2 */ }

// Логика распределения данных по шардам (например, по userId)
fun getRepositoryForUser(userId: Long): JpaRepository<User, Long> {
    return if (userId % 2 == 0L) userRepositoryShard1 else userRepositoryShard2
}
```

### 4. Писсимистичная и оптимистичная блокировка в Spring Boot с Kotlin

Оптимистичная блокировка:
```kotlin
import jakarta.persistence.*

@Entity
@Table(name = "product")
data class Product(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long = 0,
    var name: String,
    var quantity: Int,

    @Version // для оптимистичной блокировки
    val version: Long? = null
)

interface ProductRepository : JpaRepository<Product, Long>
```

Пример сервиса с оптимистичной блокировкой:
```kotlin
@Service
class ProductService(val productRepository: ProductRepository) {

    @Transactional
    fun updateQuantityOptimistic(productId: Long, delta: Int) {
        val product = productRepository.findById(productId).orElseThrow()
        product.quantity += delta
        productRepository.save(product) // При конфликте версии будет выброшено исключение OptimisticLockException
    }
}
```

Писсимистичная блокировка (с использованием `@Lock`):
```kotlin
import org.springframework.data.jpa.repository.Lock
import jakarta.persistence.LockModeType

interface ProductRepository : JpaRepository<Product, Long> {

    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("select p from Product p where p.id = :id")
    fun findByIdWithPessimisticLock(id: Long): Product
}

@Service
class ProductService(val productRepository: ProductRepository) {

    @Transactional
    fun updateQuantityPessimistic(productId: Long, delta: Int) {
        val product = productRepository.findByIdWithPessimisticLock(productId)
        product.quantity += delta
        productRepository.save(product)
    }
}
```

Эти механизмы работают независимо от Kotlin, они зависят от Spring Data JPA и базы данных (PostgreSQL поддерживает такую блокировку).[1][2][3][4][5][6][7]


[1](https://blog.algomaster.io/p/a-detailed-guide-on-database-indexes)
[2](https://neon.com/postgresql/postgresql-indexes/postgresql-create-index)
[3](https://postgrespro.ru/docs/postgresql/current/ddl-partitioning)
[4](https://stackoverflow.com/questions/129329/optimistic-vs-pessimistic-locking)
[5](https://www.youtube.com/watch?v=lR6y-0RC5cc)
[6](https://www.baeldung.com/jpa-optimistic-locking)
[7](https://www.tune-it.ru/web/dashezunka/blog/-/blogs/optimistic-vs-pessimistic-locking-v-sql)


[12](https://stackoverflow.com/questions/129329/optimistic-vs-pessimistic-locking)
[13](https://www.youtube.com/watch?v=lR6y-0RC5cc)
[14](https://www.ibm.com/docs/en/rational-clearquest/10.0.7?topic=clearquest-optimistic-pessimistic-record-locking)
[15](https://www.baeldung.com/jpa-optimistic-locking)
[16](https://www.tune-it.ru/web/dashezunka/blog/-/blogs/optimistic-vs-pessimistic-locking-v-sql)